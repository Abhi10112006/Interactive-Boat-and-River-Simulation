<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#111827" />
  <title>Cat Runner</title>
  <style>
    :root{--bg:#ffffff;--ink:#111827;--ink2:#4b5563;--pill:#111827;--accent:#f59e0b;--panel:rgba(255,255,255,.78)}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    .wrap{height:100%;display:flex;flex-direction:column}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;gap:10px}
    header .brand{font-weight:700;letter-spacing:.3px}
    .hud{position:absolute;right:10px;top:10px;background:var(--panel);backdrop-filter:saturate(1.2) blur(6px);border-radius:16px;padding:8px 10px;box-shadow:0 4px 16px rgba(0,0,0,.08)}
    .hud .row{display:flex;gap:10px;align-items:baseline}
    .hud .label{font-size:11px;color:var(--ink2)}
    .hud .value{font-variant-numeric:tabular-nums;font-weight:700}
    .bar{position:absolute;left:10px;top:10px;display:flex;gap:8px}
    kbd{background:#f3f4f6;padding:4px 8px;border-radius:12px;box-shadow:0 2px 8px rgba(0,0,0,.06);font-size:11px}
    .stage{position:relative;flex:1;min-height:420px}
    canvas{width:100%;height:100%;display:block;background:#eaf3ff}
    .controls{position:absolute;inset:auto 0 10px 0;display:flex;justify-content:space-between;padding:0 10px;pointer-events:none}
    .btn{pointer-events:auto;border:none;border-radius:18px;padding:10px 14px;background:var(--pill);color:#fff;font-weight:600;box-shadow:0 10px 20px rgba(0,0,0,.12);touch-action:manipulation}
    .btn.alt{background:var(--accent);}
    .fab{position:absolute;left:10px;bottom:70px}
    .overlay{position:absolute;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;color:#fff;text-align:center;padding:20px}
    .overlay.show{display:flex}
    .card{background:rgba(17,24,39,.9);padding:16px 18px;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .card h2{margin:0 0 8px 0;font-size:20px}
    .card p{margin:0;font-size:14px;color:#d1d5db}
    @media (min-width:800px){.controls{bottom:14px}.btn{padding:12px 18px;border-radius:22px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">üêà Cat Runner</div>
      <div class="bar">
        <kbd>Space/W/‚Üë Jump</kbd>
        <kbd>S/‚Üì Crouch</kbd>
        <kbd>P Pause</kbd>
        <kbd>R Restart</kbd>
      </div>
    </header><main class="stage">
  <canvas id="game" aria-label="Cat Runner game" role="img"></canvas>
  <div class="hud" id="hud">
    <div class="row"><span class="label">Score</span> <span class="value" id="score">0</span></div>
    <div class="row"><span class="label">Best</span> <span class="value" id="best">0</span></div>
  </div>

  <div class="controls">
    <button class="btn alt" id="btnJump" aria-label="Jump">Jump</button>
    <div>
      <button class="btn" id="btnPause" aria-label="Pause">Pause</button>
      <button class="btn alt" id="btnRestart" aria-label="Restart">Restart</button>
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h2 id="ovTitle">Paused</h2>
      <p id="ovDesc">Press P or tap Resume</p>
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:center">
        <button class="btn" id="btnResume">Resume</button>
        <button class="btn alt" id="btnOvRestart">Restart</button>
      </div>
    </div>
  </div>
</main>

  </div><script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hudScore = document.getElementById('score');
  const hudBest = document.getElementById('best');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovDesc = document.getElementById('ovDesc');

  const btnJump = document.getElementById('btnJump');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');
  const btnResume = document.getElementById('btnResume');
  const btnOvRestart = document.getElementById('btnOvRestart');

  // --- Tunables ---
  const GROUND_Y = 320; // world baseline in CSS pixels (we scale for DPR)
  const BASE_SPEED = 360;
  const MAX_SPEED = 820;
  const GRAVITY = 2600;
  const JUMP_V = -1050;
  const JUMP_CUT = 0.45;
  const COYOTE = 0.10;
  const BUFFER = 0.12;
  const AIR_DRAG = 0.0008; // proportional to v^2
  const TERMINAL = 2000;

  // --- Helpers ---
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const now = ()=>performance.now()/1000;

  const state = {
    t:0, speed: BASE_SPEED, distance:0,
    cat:{x:120,y:GROUND_Y,vy:0,onGround:true,crouch:false,coyoteLeft:0,bufferLeft:0},
    obstacles:[], birds:[], particles:[],
    spawnTimer:0, birdTimer:1.8,
    wind:0, windTimer:3,
    paused:false, over:false,
    score:0, best: Number(localStorage.getItem('catrunner_best')||0),
  };

  const input = {jumpPressed:false, jumpHeld:false, downHeld:false};

  // DPR-aware resize
  function resize(){
    const dpr = Math.min(window.devicePixelRatio||1, 2);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  function fitHeight(){
    // Make stage roughly 72vh tall like an app, but respect mobile UI
    const stage = document.querySelector('.stage');
    stage.style.height = Math.max(420, Math.floor(window.innerHeight*0.72)) + 'px';
    resize();
  }
  window.addEventListener('resize', fitHeight, {passive:true});
  fitHeight();

  // Input: keyboard
  window.addEventListener('keydown', e=>{
    if(e.repeat) return;
    const k = e.key;
    if([' ','Spacebar','ArrowUp','w','W'].includes(k)) { input.jumpPressed=true; input.jumpHeld=true; e.preventDefault(); }
    else if(['ArrowDown','s','S'].includes(k)) input.downHeld=true;
    else if(k==='p' || k==='P') togglePause();
    else if(k==='r' || k==='R') restart();
  });
  window.addEventListener('keyup', e=>{
    const k=e.key;
    if([' ','Spacebar','ArrowUp','w','W'].includes(k)) input.jumpHeld=false;
    else if(['ArrowDown','s','S'].includes(k)) input.downHeld=false;
  });

  // Input: touch / on-screen buttons
  const onPressJump = ()=>{ input.jumpPressed=true; input.jumpHeld=true; };
  const onReleaseJump = ()=>{ input.jumpHeld=false; };
  btnJump.addEventListener('touchstart', e=>{e.preventDefault(); onPressJump();});
  btnJump.addEventListener('touchend', e=>{e.preventDefault(); onReleaseJump();});
  btnJump.addEventListener('mousedown', e=>{onPressJump();});
  window.addEventListener('mouseup', e=>{onReleaseJump();});

  // Tap anywhere on canvas to jump
  canvas.addEventListener('pointerdown', e=>{ onPressJump(); });
  window.addEventListener('pointerup', e=>{ onReleaseJump(); input.downHeld=false; });

  // Crouch: hold left half of screen / long-press secondary button in future
  // For now, map crouch to two-finger touch or press-and-hold Pause button
  let activeTouches = new Set();
  window.addEventListener('touchstart', e=>{
    for(const t of e.changedTouches) activeTouches.add(t.identifier);
    input.downHeld = activeTouches.size>=2; // two-finger = crouch
  }, {passive:true});
  window.addEventListener('touchend', e=>{
    for(const t of e.changedTouches) activeTouches.delete(t.identifier);
    input.downHeld = activeTouches.size>=2;
  }, {passive:true});

  btnPause.addEventListener('click', togglePause);
  btnRestart.addEventListener('click', restart);
  btnResume.addEventListener('click', ()=>{ if(state.over){ state.over=false; } state.paused=false; hideOverlay(); });
  btnOvRestart.addEventListener('click', restart);

  function togglePause(){
    if(state.over) return; 
    state.paused = !state.paused;
    if(state.paused){ showOverlay('Paused','Press P or tap Resume'); btnPause.textContent='Resume'; }
    else { hideOverlay(); btnPause.textContent='Pause'; }
  }

  function restart(){
    Object.assign(state, {
      t:0, speed:BASE_SPEED, distance:0,
      cat:{x:120,y:GROUND_Y,vy:0,onGround:true,crouch:false,coyoteLeft:0,bufferLeft:0},
      obstacles:[], birds:[], particles:[],
      spawnTimer:0, birdTimer:1.8,
      wind:0, windTimer:3,
      paused:false, over:false,
      score:0, best: state.best
    });
    btnPause.textContent='Pause';
    hideOverlay();
  }

  function showOverlay(title, desc){ overlay.classList.add('show'); ovTitle.textContent=title; ovDesc.textContent=desc; }
  function hideOverlay(){ overlay.classList.remove('show'); }

  // Drawing helpers
  function roundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawCat(x,y,crouch,t){
    ctx.save();
    ctx.translate(x,y);
    const tailSwing = Math.sin(t*8) * (crouch?2:6);
    // shadow
    ctx.fillStyle='rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(0,26,24,8,0,0,Math.PI*2); ctx.fill();

    // body colors
    ctx.fillStyle='#2d2d2d'; ctx.strokeStyle='#111'; ctx.lineWidth=2;
    // tail
    ctx.save(); ctx.translate(-24,4); ctx.rotate(tailSwing*Math.PI/180); roundedRect(-18,-4,24,8,4); ctx.fill(); ctx.stroke(); ctx.restore();
    // torso
    roundedRect(-18,-10,36,22,8); ctx.fill(); ctx.stroke();
    // head
    ctx.save(); ctx.translate(18,-6); roundedRect(-12,-10,22,20,6); ctx.fill(); ctx.stroke();
    // ears
    ctx.beginPath();
    ctx.moveTo(-10,-10); ctx.lineTo(-4,-18); ctx.lineTo(0,-8); ctx.closePath();
    ctx.moveTo(6,-10); ctx.lineTo(10,-18); ctx.lineTo(12,-6); ctx.closePath();
    ctx.fillStyle='#1f1f1f'; ctx.fill();
    // eye
    ctx.fillStyle='#f3f99d'; ctx.beginPath(); ctx.arc(2,-2,2,0,Math.PI*2); ctx.fill();
    // nose
    ctx.fillStyle='#f59e0b'; ctx.fillRect(-2,2,3,2);
    ctx.restore();

    // legs
    const step = Math.sin(t*18) * (crouch?1:3);
    ctx.save(); ctx.translate(-10,12); roundedRect(-3+step,0,6,12,3); ctx.fill(); ctx.translate(20,0); roundedRect(-3-step,0,6,12,3); ctx.fill(); ctx.restore();
    ctx.restore();
  }

  function drawCactus(x,groundY,h,w){
    ctx.save(); ctx.translate(x,groundY-h); ctx.fillStyle='#0b8a5a'; roundedRect(0,0,w,h,6); ctx.fill();
    ctx.fillRect(w*0.15, h*0.35, w*0.2, h*0.18);
    ctx.fillRect(w*0.65, h*0.5,  w*0.2, h*0.18);
    ctx.restore();
  }
  function drawBird(x,y,t){
    ctx.save(); ctx.translate(x,y); ctx.fillStyle='#333';
    ctx.beginPath(); ctx.ellipse(0,0,16,10,0,0,Math.PI*2); ctx.fill();
    const fl = Math.sin(t*16)*8+12; ctx.beginPath(); ctx.moveTo(-6,0); ctx.quadraticCurveTo(-16,-fl,-28,0); ctx.quadraticCurveTo(-16,fl,-6,0); ctx.fill();
    ctx.restore();
  }

  function parallax(w,h,offset,scale){
    ctx.save(); ctx.translate(-offset,0);
    ctx.fillStyle = scale<0.3 ? '#bcd1ea' : (scale<0.6 ? '#9fc0e4' : '#86b2de');
    for(let x=-200; x<w+200; x+=180){
      ctx.beginPath(); const baseY = GROUND_Y-60*scale; ctx.moveTo(x,baseY);
      ctx.quadraticCurveTo(x+60, baseY-50*scale, x+120, baseY);
      ctx.quadraticCurveTo(x+160, baseY+18*scale, x+180, baseY);
      ctx.fill();
    }
    ctx.restore();
  }

  function aabb(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y }

  function spawnDust(x,y,count,life){
    for(let i=0;i<count;i++) state.particles.push({
      x:x+rand(-6,6), y:y+rand(-4,4), vx:rand(20,140)*(Math.random()<.5?-1:1), vy:rand(-220,-80), r:rand(1.5,3.5), life:rand(.2*life,.5*life)
    });
  }

  // Fixed-step loop
  let last = performance.now();
  const FIXED = 1/120; let acc=0;
  function frame(ts){
    const dt = (ts-last)/1000; last=ts; if(dt>0.25) {acc=0;} else acc+=dt;
    while(acc>=FIXED){ step(FIXED); acc-=FIXED; }
    render(); requestAnimationFrame(frame);
  }

  function step(dt){
    if(state.paused || state.over) return;
    state.t += dt;

    const cat = state.cat;
    // difficulty & wind
    const targetSpeed = clamp(BASE_SPEED + state.distance*0.05, BASE_SPEED, MAX_SPEED);
    state.speed += (targetSpeed-state.speed) * (1-Math.exp(-dt*0.8));
    state.windTimer -= dt; if(state.windTimer<=0){ state.wind=rand(-40,60); state.windTimer=rand(3.5,7.5);} 
    const worldSpeed = state.speed + state.wind;

    // spawns
    state.spawnTimer -= dt;
    if(state.spawnTimer<=0){
      const gap = clamp(220 - state.speed*0.15, 120, 220);
      const w = rand(24,48) * rand(1,1.6), h = rand(38,92);
      state.obstacles.push({x:canvas.clientWidth+w, y:GROUND_Y-h, w, h, type:'cactus'});
      state.spawnTimer = rand(gap/200, gap/120);
    }
    state.birdTimer -= dt;
    if(state.birdTimer<=0){ const by = GROUND_Y - rand(90,180); state.birds.push({x:canvas.clientWidth+40,y:by,v:-worldSpeed*rand(.85,1.15)}); state.birdTimer = rand(1.6,3.2); }

    // update movers
    for(let i=state.obstacles.length-1;i>=0;i--){ const o=state.obstacles[i]; o.x -= worldSpeed*dt; if(o.x+o.w<-50) state.obstacles.splice(i,1); }
    for(let i=state.birds.length-1;i>=0;i--){ const b=state.birds[i]; b.x += b.v*dt; b.y += Math.sin((state.t+i)*2.2)*18*dt; if(b.x<-80) state.birds.splice(i,1); }

    // input 
    cat.crouch = input.downHeld && cat.onGround;
    cat.coyoteLeft = cat.onGround ? COYOTE : Math.max(0, cat.coyoteLeft-dt);
    cat.bufferLeft = input.jumpPressed ? BUFFER : Math.max(0, cat.bufferLeft-dt);
    input.jumpPressed=false;

    const height = cat.crouch ? 26 : 38; const width = cat.crouch ? 48 : 44;

    // jump
    if(cat.bufferLeft>0 && (cat.onGround || cat.coyoteLeft>0)){
      cat.vy = JUMP_V * (cat.crouch?0.86:1);
      cat.onGround=false; cat.coyoteLeft=0; cat.bufferLeft=0; spawnDust(cat.x-6,GROUND_Y,6,2);
    }

    // gravity + cut + drag
    cat.vy += GRAVITY*dt;
    if(!input.jumpHeld && cat.vy<0){ cat.vy += (-cat.vy)*(1-JUMP_CUT)*10*dt; }
    const drag = AIR_DRAG*cat.vy*Math.abs(cat.vy); cat.vy -= Math.sign(cat.vy)*drag*dt;
    cat.vy = clamp(cat.vy, -TERMINAL, TERMINAL);
    cat.y += cat.vy*dt;

    // ground
    if(cat.y>GROUND_Y){
      if(!cat.onGround && Math.abs(cat.vy)>200) spawnDust(cat.x-10,GROUND_Y, clamp(Math.abs(cat.vy)/160,6,14), 3);
      cat.y=GROUND_Y; cat.vy=0; cat.onGround=true;
    } else cat.onGround=false;

    // friction when crouching (slows diff. scaling a bit)
    if(cat.onGround && cat.crouch){ state.speed -= (state.speed-BASE_SPEED)*(1-Math.exp(-dt*1.6)); }

    // collisions
    const catBox = {x: cat.x-width/2, y: cat.y-height, w: width, h: height};
    for(const o of state.obstacles){ if(aabb(catBox,{x:o.x,y:o.y,w:o.w,h:o.h})) return endGame(); }
    for(const b of state.birds){ if(aabb(catBox,{x:b.x-20,y:b.y-12,w:40,h:24})) return endGame(); }

    // particles
    for(let i=state.particles.length-1;i>=0;i--){ const p=state.particles[i]; p.life-=dt; p.x += p.vx*dt - worldSpeed*dt*0.4; p.y += p.vy*dt; p.vy += GRAVITY*0.35*dt; if(p.life<=0) state.particles.splice(i,1);} 

    // scoring
    state.distance += worldSpeed*dt; state.score = Math.floor(state.distance/2);
    hudScore.textContent = state.score;
    hudBest.textContent = Math.max(state.best, state.score);
  }

  function endGame(){
    state.over = true; state.paused=false; 
    state.best = Math.max(state.best, state.score);
    localStorage.setItem('catrunner_best', String(state.best));
    hudBest.textContent = state.best;
    btnPause.textContent='Pause';
    showOverlay('Game Over','Tap Restart or press R');
  }

  function render(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    // background
    ctx.fillStyle='#eaf3ff'; ctx.fillRect(0,0,w,h);
    const t = state.t, speed = state.speed||BASE_SPEED;
    parallax(w,h, (t*(speed*.15)) % (w+200), .25);
    parallax(w,h, (t*(speed*.35)) % (w+200), .5);

    // ground
    ctx.fillStyle='#f5e6c5'; ctx.fillRect(0,GROUND_Y+8, w, h-(GROUND_Y+8));
    ctx.fillStyle='#d1bfa0'; ctx.fillRect(0,GROUND_Y+6, w, 2);

    // entities
    for(const o of state.obstacles) drawCactus(o.x, GROUND_Y, o.h, o.w);
    for(const b of state.birds) drawBird(b.x, b.y, state.t);

    // particles
    for(const p of state.particles){ ctx.globalAlpha = clamp(p.life,0,1); ctx.fillStyle='#d1bfa0'; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }

    // cat
    drawCat(state.cat.x, state.cat.y-(state.cat.crouch?10:16), state.cat.crouch, state.t);

    // overlays are DOM; nothing else here
  }

  // kick it off
  requestAnimationFrame(frame);
})();
</script></body>
</html>
