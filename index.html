<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Cat Runner</title>
   <style>
       @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
       
       :root {
           --bg-color: #e0f7fa;
           --main-color: #263238;
           --accent-color: #ff9800;
       }

       body {
           font-family: 'Press Start 2P', cursive;
           background-color: var(--bg-color);
           color: var(--main-color);
           display: flex;
           justify-content: center;
           align-items: center;
           height: 100vh;
           margin: 0;
           overflow: hidden;
           flex-direction: column;
       }

       #game-container {
           position: relative;
           border: 5px solid var(--main-color);
           box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
           border-radius: 15px;
           overflow: hidden;
           background: linear-gradient(to bottom, #87ceeb, #e0f7fa);
           width: 90vw;
           height: 50vw;
           max-width: 900px;
           max-height: 500px;
       }

       canvas {
           display: block;
           width: 100%;
           height: 100%;
       }

       #ui-overlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           display: flex;
           flex-direction: column;
           justify-content: space-between;
           align-items: center;
           padding: 1rem;
           box-sizing: border-box;
           pointer-events: none; /* Allows clicks to pass through to the canvas */
       }

       .score-display {
           display: flex;
           width: 100%;
           justify-content: flex-end;
           gap: 2rem;
       }

       .score-item {
           font-size: 1.5rem;
           text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
       }

       #game-over-screen {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           background-color: rgba(255, 255, 255, 0.9);
           display: none;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           text-align: center;
           border-radius: 15px;
           pointer-events: all;
       }

       #game-over-screen h2 {
           font-size: 2.5rem;
           margin-bottom: 1rem;
           color: var(--accent-color);
       }

       #game-over-screen p {
           font-size: 1.2rem;
           margin-bottom: 2rem;
       }

       #restart-btn {
           background-color: var(--main-color);
           color: #fff;
           padding: 1rem 2rem;
           border-radius: 50px;
           font-family: 'Press Start 2P', cursive;
           font-size: 1rem;
           border: none;
           cursor: pointer;
           transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
           box-shadow: 0 5px 10px rgba(0,0,0,0.2);
       }

       #restart-btn:hover {
           transform: translateY(-3px);
           box-shadow: 0 8px 15px rgba(0,0,0,0.3);
       }

       #cat-sprite-container {
           position: absolute;
           bottom: 0;
           left: 10%;
           width: 80px;
           height: 80px;
           transform-origin: bottom;
       }
       
       .hidden {
           display: none;
       }

       .jump-animation {
           animation: jump-arc 0.5s ease-out;
       }

       @keyframes jump-arc {
           0% { transform: translateY(0); }
           50% { transform: translateY(-100px); }
           100% { transform: translateY(0); }
       }
   </style>
</head>
<body>
   <div id="game-container">
       <canvas id="game-canvas"></canvas>
       <div id="ui-overlay">
           <div class="score-display">
               <div class="score-item">HI <span id="high-score">0</span></div>
               <div class="score-item">SCORE <span id="current-score">0</span></div>
           </div>
           <div id="game-over-screen">
               <h2>GAME OVER</h2>
               <p>Score: <span id="final-score">0</span></p>
               <button id="restart-btn">RESTART</button>
           </div>
       </div>
   </div>

   <!-- External Libraries -->
   <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/tone@14.7.58/build/Tone.min.js"></script>

   <script>
       // --- Core Game Setup ---
       const gameContainer = document.getElementById('game-container');
       const canvas = document.getElementById('game-canvas');
       const context = canvas.getContext('2d');
       const gameOverScreen = document.getElementById('game-over-screen');
       const restartBtn = document.getElementById('restart-btn');
       const scoreSpan = document.getElementById('current-score');
       const highScoreSpan = document.getElementById('high-score');
       const finalScoreSpan = document.getElementById('final-score');

       // --- Physics Engine Initialization ---
       const { Engine, Render, World, Bodies, Events, Runner, Body } = Matter;
       let engine;
       let render;
       let runner;
       let cat;
       let ground;
       let obstacles = [];
       let gameSpeed = 1;
       let score = 0;
       let isRunning = false;
       let isJumping = false;
       let isDucking = false;
       let obstacleTimer = 0;
       let obstacleSpawnInterval = 1000;
       let lastTimestamp = 0;
       let highscore = localStorage.getItem('catRunnerHighScore') || 0;

       // --- Cat State and Appearance ---
       const catStates = {
           running: { color: '#fdd835', size: { width: 40, height: 60 } },
           jumping: { color: '#ffeb3b', size: { width: 40, height: 60 } },
           ducking: { color: '#ffc107', size: { width: 60, height: 40 } },
           collision: { color: '#d32f2f' }
       };

       // --- Sound Effects Setup using Tone.js ---
       const jumpSound = new Tone.Synth({
           oscillator: { type: "square" },
           envelope: {
               attack: 0.005,
               decay: 0.1,
               sustain: 0,
               release: 0.1
           }
       }).toDestination();

       const collisionSound = new Tone.NoiseSynth({
           noise: { type: "white" },
           envelope: {
               attack: 0.001,
               decay: 0.1,
               sustain: 0.1,
               release: 0.1
           }
       }).toDestination();
       
       const backgroundMusic = new Tone.Loop(time => {
           // A simple, repeating tone for background music
           Tone.Transport.bpm.value = 120 + score / 100;
           new Tone.Synth().triggerAttackRelease("C4", "8n", time);
           new Tone.Synth().triggerAttackRelease("G4", "8n", time + 0.25);
           new Tone.Synth().triggerAttackRelease("A4", "8n", time + 0.5);
           new Tone.Synth().triggerAttackRelease("F4", "8n", time + 0.75);
       }, "1m").start(0);

       // --- Game Logic Functions ---

       /**
        * Initializes or resets the game state.
        */
       function init() {
           // Set initial state
           isJumping = false;
           isDucking = false;
           isRunning = true;
           score = 0;
           gameSpeed = 1;
           obstacles = [];
           
           // UI updates
           scoreSpan.textContent = score;
           highScoreSpan.textContent = highscore;
           gameOverScreen.style.display = 'none';

           // Matter.js setup
           if (engine) {
               World.clear(engine.world, false);
               Engine.clear(engine);
           }
           engine = Engine.create({ gravity: { scale: 0.0015 } });
           
           // Responsive canvas sizing
           resizeCanvas();

           render = Render.create({
               canvas: canvas,
               engine: engine,
               options: {
                   width: canvas.width,
                   height: canvas.height,
                   showVelocity: false,
                   showCollisions: false,
                   wireframes: false,
                   background: 'transparent'
               }
           });

           // Create game objects
           ground = Bodies.rectangle(canvas.width / 2, canvas.height - 20, canvas.width, 40, {
               isStatic: true,
               render: { fillStyle: '#4caf50' }
           });

           cat = Bodies.rectangle(100, canvas.height - 40 - 30, catStates.running.size.width, catStates.running.size.height, {
               inertia: Infinity, // Prevent rotation
               label: 'cat'
           });

           World.add(engine.world, [ground, cat]);
           
           // Start the physics runner
           runner = Runner.run(engine);
           Render.run(render);
           
           // Start background music
           Tone.Transport.start();
       }

       /**
        * Resizes the canvas to fit the container.
        */
       function resizeCanvas() {
           const rect = gameContainer.getBoundingClientRect();
           canvas.width = rect.width;
           canvas.height = rect.height;
       }

       /**
        * The main game loop.
        */
       function gameLoop(timestamp) {
           if (!isRunning) return;
           
           const deltaTime = timestamp - lastTimestamp;
           lastTimestamp = timestamp;

           // Update game logic
           updateGame(deltaTime);

           // Render custom sprites/shapes
           drawObjects();

           requestAnimationFrame(gameLoop);
       }

       /**
        * Updates game state, score, and obstacle generation.
        */
       function updateGame(deltaTime) {
           score += Math.floor(deltaTime * gameSpeed / 100);
           scoreSpan.textContent = score;
           gameSpeed += 0.0001; // Increase speed over time

           obstacleTimer += deltaTime * gameSpeed;
           if (obstacleTimer > obstacleSpawnInterval) {
               spawnObstacle();
               obstacleTimer = 0;
               obstacleSpawnInterval = 1000 / gameSpeed;
           }

           // Move obstacles and check if they are off-screen
           obstacles.forEach(obstacle => {
               Body.setVelocity(obstacle, { x: -3 * gameSpeed, y: obstacle.velocity.y });
           });

           // Remove off-screen obstacles to prevent performance issues
           obstacles = obstacles.filter(obstacle => {
               const isOffScreen = obstacle.position.x < -50;
               if (isOffScreen) {
                   World.remove(engine.world, obstacle);
               }
               return !isOffScreen;
           });
       }

       /**
        * Spawns a new obstacle at a random interval.
        */
       function spawnObstacle() {
           const random = Math.random();
           let obstacle;
           let obstacleWidth;
           let obstacleHeight;
           let obstacleType = Math.floor(Math.random() * 4);
           const obstacleX = canvas.width + 50;

           switch (obstacleType) {
               case 0: // Fence (a tall, thin obstacle)
                   obstacleWidth = 20;
                   obstacleHeight = 50;
                   obstacle = Bodies.rectangle(obstacleX, canvas.height - 20 - (obstacleHeight / 2), obstacleWidth, obstacleHeight, {
                       isStatic: false,
                       label: 'obstacle',
                       restitution: 0.1,
                       render: { fillStyle: '#bcaaa4' }
                   });
                   break;
               case 1: // Puddle (a low, wide obstacle, easy to jump over)
                   obstacleWidth = 60;
                   obstacleHeight = 20;
                   obstacle = Bodies.rectangle(obstacleX, canvas.height - 20 - (obstacleHeight / 2), obstacleWidth, obstacleHeight, {
                       isStatic: false,
                       label: 'obstacle',
                       restitution: 0.8, // Bouncy
                       render: { fillStyle: '#2196f3' }
                   });
                   break;
               case 2: // Dog (a medium-sized moving obstacle)
                   obstacleWidth = 40;
                   obstacleHeight = 40;
                   obstacle = Bodies.rectangle(obstacleX, canvas.height - 20 - (obstacleHeight / 2), obstacleWidth, obstacleHeight, {
                       isStatic: false,
                       label: 'obstacle',
                       restitution: 0.2,
                       render: { fillStyle: '#795548' }
                   });
                   break;
               case 3: // Bird (an obstacle that requires a low duck)
                   obstacleWidth = 30;
                   obstacleHeight = 30;
                   obstacle = Bodies.rectangle(obstacleX, canvas.height - 20 - 70 - (obstacleHeight / 2), obstacleWidth, obstacleHeight, {
                       isStatic: false,
                       label: 'obstacle',
                       restitution: 0.1,
                       render: { fillStyle: '#f44336' }
                   });
                   break;
           }

           if (obstacle) {
               obstacles.push(obstacle);
               World.add(engine.world, obstacle);
           }
       }

       /**
        * Handles drawing all objects on the canvas, including custom cat rendering.
        */
       function drawObjects() {
           // Clear the canvas
           context.clearRect(0, 0, canvas.width, canvas.height);

           // Cat's Body
           context.fillStyle = isJumping ? catStates.jumping.color : (isDucking ? catStates.ducking.color : catStates.running.color);
           context.beginPath();
           context.roundRect(cat.position.x - cat.bounds.width / 2, cat.position.y - cat.bounds.height / 2, cat.bounds.width, cat.bounds.height, 10);
           context.fill();
           
           // Cat's eye (simple circle)
           context.fillStyle = '#000';
           context.beginPath();
           context.arc(cat.position.x + cat.bounds.width / 4, cat.position.y - cat.bounds.height / 4, 3, 0, 2 * Math.PI);
           context.fill();

           // Matter.js automatically handles rendering the ground and obstacles
           // The renderer is already running, so we don't need to manually draw them here.
       }

       /**
        * Manages game state on collision.
        */
       function handleCollisions(event) {
           const pairs = event.pairs;
           for (const pair of pairs) {
               const bodyA = pair.bodyA;
               const bodyB = pair.bodyB;

               if ((bodyA.label === 'cat' && bodyB.label === 'obstacle') ||
                   (bodyB.label === 'cat' && bodyA.label === 'obstacle')) {
                   // Game Over
                   collisionSound.triggerAttackRelease("8n");
                   endGame();
               }
           }
       }

       /**
        * Ends the game and displays the final score.
        */
       function endGame() {
           isRunning = false;
           Tone.Transport.stop();
           Runner.stop(runner);
           
           finalScoreSpan.textContent = score;
           gameOverScreen.style.display = 'flex';
           
           if (score > highscore) {
               highscore = score;
               localStorage.setItem('catRunnerHighScore', highscore);
               highScoreSpan.textContent = highscore;
           }
       }

       // --- Event Listeners and Game Control ---
       
       // Restart button
       restartBtn.addEventListener('click', () => {
           init();
           requestAnimationFrame(gameLoop);
       });

       // Keyboard controls
       document.addEventListener('keydown', (e) => {
           if (!isRunning) return;

           if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
               if (!isJumping) {
                   Body.setVelocity(cat, { x: cat.velocity.x, y: 0 }); // Reset vertical velocity
                   Body.applyForce(cat, cat.position, { x: 0, y: -0.1 });
                   isJumping = true;
                   jumpSound.triggerAttackRelease("C5", "8n");
               }
           } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
               if (!isDucking && !isJumping) {
                   Body.scale(cat, 1, 0.5);
                   isDucking = true;
               }
           }
       });

       document.addEventListener('keyup', (e) => {
           if (e.code === 'ArrowDown' || e.code === 'KeyS') {
               if (isDucking) {
                   Body.scale(cat, 1, 2);
                   isDucking = false;
               }
           }
       });

       // Reset jumping state on landing
       Events.on(engine, 'collisionStart', (event) => {
           const pairs = event.pairs;
           for (const pair of pairs) {
               const bodyA = pair.bodyA;
               const bodyB = pair.bodyB;
               if (bodyA.label === 'cat' && bodyB.label !== 'obstacle' || bodyB.label === 'cat' && bodyA.label !== 'obstacle') {
                   isJumping = false;
               }
           }
       });

       // Window resize event
       window.addEventListener('resize', resizeCanvas);
       
       // Collision detection event
       Events.on(engine, 'collisionStart', handleCollisions);

       // Initial setup and start the game loop
       window.onload = function() {
           init();
           requestAnimationFrame(gameLoop);
       };
   </script>
</body>
</html>
